import os
from flask import Flask, render_template, request, jsonify

app = Flask(__name__)

# --- 2026 Edition: 順番表 (81文字環状構造) ---
CHARS_CIRCLE = ["ア", "イ", "ウ", "エ", "オ", "カ", "キ", "ク", "ケ", "コ", "ガ", "ギ", "グ", "ゲ", "ゴ", "サ", "シ", "ス", "セ", "ソ", "ザ", "ジ", "ズ", "ゼ", "ゾ", "タ", "チ", "ツ", "テ", "ト", "ダ", "ヂ", "ヅ", "デ", "ド", "ナ", "ニ", "ヌ", "ネ", "ノ", "ハ", "ヒ", "フ", "ヘ", "ホ", "バ", "ビ", "ブ", "ベ", "ボ", "パ", "ピ", "プ", "ペ", "ポ", "マ", "ミ", "ム", "メ", "モ", "ヤ", "ユ", "ヨ", "ラ", "リ", "ル", "レ", "ロ", "ワ", "ン"]
SMALL_TO_LARGE = {"ァ": "ア", "ィ": "イ", "ゥ": "ウ", "ェ": "エ", "ォ": "オ", "ッ": "ツ", "ャ": "ヤ", "ュ": "ユ", "ョ": "ヨ", "ヮ": "ワ"}
VOICE_MAP = str.maketrans("ガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポ", "カキクケコサシスセソタチツテトハヒフヘホハヒフヘホ")

# データベース（提供された387単語）
DATA_STORE = {
    "countries": ["アイスランド", "アイルランド", "アゼルバイジャン", "アフガニスタン", "アメリカ", "アラブシュチョウコクレンポウ", "アルジェリア", "アルゼンチン", "アルバニア", "アルメニア", "アンゴラ", "アンティグアバーブーダ", "アンドラ", "イエメン", "イギリス", "イスラエル", "イタリア", "イラク", "イラン", "インド", "インドネシア", "ウガンダ", "ウクライナ", "ウズベキスタン", "ウルグアイ", "エクアドル", "エジプト", "エストニア", "エスワティニ", "エチオピア", "エリトリア", "エルサルバドル", "オーストラリア", "オーストリア", "オマーン", "オランダ", "ガーナ", "カーボベルデ", "ガイアナ", "カザフスタン", "カタール", "カナダ", "ガボン", "カメルーン", "ガンビア", "カンボジア", "キタマケドニア", "ギニア", "ギニアビサウ", "キプロス", "キューバ", "ギリシャ", "キリバス", "キルギス", "グアテマラ", "クウェート", "クックショトウ", "グレナダ", "クロアチア", "ケニア", "コートジボワール", "コスタリカ", "コソボ", "コモロ", "コロンビア", "コンゴキョウワコク", "コンゴミンシュキョウワコク", "サウジアラビア", "サモア", "サントメプリンシペ", "ザンビア", "サンマリノ", "シエラレオネ", "ジブチ", "ジャマイカ", "ジョージア", "シリア", "シンガポール", "ジンバブエ", "スイス", "スウェーデン", "スーダン", "スペイン", "スリナム", "スリランカ", "スロバキア", "スロベニア", "セーシェル", "セキドウギニア", "セネガル", "セルビア", "セントクリストファーネービス", "セントビンセントグレナディーンショトウ", "セントルシア", "ソマリア", "ソロモンショトウ", "タイ", "ダイカンミンコク", "タジキスタン", "タンザニア", "チェコ", "チャド", "チュウオウアフリカ", "チュウカジンミンキョウワコク", "チュニジア", "チョウセンミンシュシュギジンミンキョウワコク", "チリ", "ツバル", "デンマーク", "ドイツ", "トーゴ", "ドミニカキョウワコク", "ドミニカコク", "トリニダードトバゴ", "トルクメニスタン", "トルコ", "トンガ", "ナイジェリア", "ナウル", "ナミビア", "ニウエ", "ニカラグア", "ニジェール", "ニホン", "ニュージーランド", "ネパール", "ノルウェー", "バーレーン", "ハイチ", "パキスタン", "バチカンシコク", "パナマ", "バヌアツ", "バハマ", "パプアニューギニア", "パラオ", "パラグアイ", "バルバドス", "ハンガリー", "バングラデシュ", "ヒガシティモール", "フィジー", "フィリピン", "フィンランド", "ブータン", "ブラジル", "フランス", "ブルガリア", "ブルキナファソ", "ブルネイ", "ブルンジ", "ベトナム", "ベナン", "ベネズエラ", "ベラルーシ", "ベリーズ", "ペルー", "ベルギー", "ポーランド", "ボスニアヘルツェゴビナ", "ボツワナ", "ボリビア", "ポルトガル", "ホンジュラス", "マーシャルショトウ", "マダガスカル", "マラウイ", "マリ", "マルタ", "マレーシア", "ミクロネシアレンポウ", "ミナミアフリカキョウワコク", "ミナミスーダン", "ミャンマー", "メキシコ", "モーリシャス", "モーリタニア", "モザンビーク", "モナコ", "モルディブ", "モルドバ", "モロッコ", "モンゴル", "モンテネグロ", "ヨルダン", "ラオス", "ラトビア", "リトアニア", "リビア", "リヒテンシュタイン", "リベリア", "ルーマニア", "ルクセンブルク", "ルワンダ", "レソト", "レバノン", "ロシア"],
    "capitals": ["アクラ", "アシガバット", "アスタナ", "アスマラ", "アスンシオン", "アディスアベバ", "アテネ", "アバルア", "アピア", "アブジャ", "アブダビ", "アムステルダム", "アルジェ", "アロフィ", "アンカラ", "アンタナナリボ", "アンドララベリャ", "アンマン", "イスラマバード", "ウィーン", "ウィントフック", "ウェリントン", "ウランバートル", "エルサレム", "エレバン", "オスロ", "オタワ", "カイロ", "カストリーズ", "カトマンズ", "カブール", "カラカス", "カンパラ", "キーウ", "キガリ", "キシナウ", "ギテガ", "キト", "キャンベラ", "キングスタウン", "キングストン", "キンシャサ", "グアテマラシティ", "クアラルンプール", "クウェート", "コナクリ", "コペンハーゲン", "ザグレブ", "サヌア", "サラエボ", "サンサルバドル", "サンティアゴ", "サントドミンゴ", "サントメ", "サンホセ", "サンマリノ", "ジブチ", "ジャカルタ", "ジュバ", "ジョージタウン", "シンガポール", "スコピエ", "ストックホルム", "スバ", "スリジャヤワルダナプラコッテ", "セントジョージズ", "セントジョンズ", "ソウル", "ソフィア", "ダカール", "タシケント", "ダッカ", "ダブリン", "ダマスカス", "タラワ", "タリン", "チュニス", "ティラナ", "ディリ", "ティンプー", "テグシガルパ", "テヘラン", "デリー", "トウキョウ", "ドゥシャンベ", "ドーハ", "ドドマ", "トビリシ", "トリポリ", "ナイロビ", "ナッソー", "ニアメ", "ニコシア", "ヌアクショット", "ヌクアロファ", "ネピドー", "バクー", "バグダッド", "バセテール", "パナマシティ", "バチカン", "ハノイ", "ハバナ", "ハボローネ", "バマコ", "パラマリボ", "ハラレ", "パリ", "パリキール", "ハルツーム", "バレッタ", "バンギ", "バンコク", "バンジュール", "バンダルスリブガワン", "ビエンチャン", "ビクトリア", "ビサウ", "ビシュケク", "ピョンヤン", "ビリニュス", "ファドゥーツ", "ブエノスアイレス", "ブカレスト", "ブダペスト", "フナフティ", "プノンペン", "プライア", "ブラザビル", "ブラジリア", "ブラちスラバ", "プラハ", "フリータウン", "プリシュティナ", "ブリッジタウン", "ブリュッセル", "プレトリア", "ベイルート", "ベオグラード", "ペキン", "ヘルシンキ", "ベルモパン", "ベルリン", "ベルン", "ポートオブスペイン", "ポートビラ", "ポートモレスビー", "ポートルイス", "ボゴタ", "ポドゴリツァ", "ホニアラ", "ポルトープランス", "ポルトノボ", "マジュロ", "マスカット", "マセル", "マドリード", "マナーマ", "マナグア", "マニラ", "マプト", "マラボ", "マルキョク", "マレ", "ミンスク", "ムババーネ", "メキシコシティ", "モガディシュ", "モスクワ", "モナコ", "モロニ", "モンテビデオ", "モンロビア", "ヤウンデ", "ヤムスクロ", "ヤレン", "ラパス", "ラバト", "リーブルビル", "リガ", "リスボン", "リマ", "リヤド", "リュブリャナ", "リロングウェ", "ルアンダ", "ルクセンブルク", "ルサカ", "レイキャビク", "ローマ", "ロゾー", "ロメ", "ロンドン", "ワガドゥグー", "ワシントンディーシー", "ワルシャワ", "ンジャメナ"]
}

def get_clean_char(c, ignore_voiced):
    if not c: return ""
    res = SMALL_TO_LARGE.get(c, c)
    if ignore_voiced: res = res.translate(VOICE_MAP)
    return res

def get_target_char(word, shift_count, ignore_voiced, step, is_gyukou):
    if not word: return None
    # 接続元文字の選定
    if is_gyukou and step % 2 == 0:
        base_char = word[0]
    else:
        base_char = word.replace("ー", "")[-1]
    
    base_char = SMALL_TO_LARGE.get(base_char, base_char)
    try:
        idx = CHARS_CIRCLE.index(base_char)
        res_char = CHARS_CIRCLE[(idx + shift_count) % len(CHARS_CIRCLE)]
        return get_clean_char(res_char, ignore_voiced)
    except:
        return None

@app.route('/')
def index():
    all_words = sorted(list(set(DATA_STORE["countries"] + DATA_STORE["capitals"])))
    return render_template('index.html', all_words=all_words)

@app.route('/search', methods=['POST'])
def search():
    d = request.json
    start_word = d.get('start_word', "")
    start_char = get_clean_char(d.get('start_char', ""), d.get('ignore_voiced'))
    must_char = get_clean_char(d.get('must_char', ""), d.get('ignore_voiced'))
    end_char = get_clean_char(d.get('end_char', ""), d.get('ignore_voiced'))
    shift_count = int(d.get('shift_count', 1))
    is_gyukou = d.get('is_gyukou', False)
    ignore_voiced = d.get('ignore_voiced', False)
    exclude_conjugate = d.get('exclude_conjugate', False)
    category = d.get('category', 'both')
    max_len = int(d.get('max_len', 5))
    word_configs = d.get('word_configs', {})
    sort_type = d.get('sort_type', 'default')

    if category == "countries": raw_pool = DATA_STORE["countries"]
    elif category == "capitals": raw_pool = DATA_STORE["capitals"]
    else: raw_pool = DATA_STORE["countries"] + DATA_STORE["capitals"]

    pool = [w for w in raw_pool if word_configs.get(w) != 2]
    
    # 共役排除フィルタ
    if exclude_conjugate:
        def is_conjugate(w):
            h = get_clean_char(w[0], ignore_voiced)
            t = get_clean_char(w.replace("ー", "")[-1], ignore_voiced)
            return h == t
        pool = [w for w in pool if not is_conjugate(w)]

    must_words = [w for w, v in word_configs.items() if v == 1]
    results = []

    def solve(path):
        if len(results) >= 10000: return
        if len(path) == max_len:
            if not all(m in path for m in must_words): return
            if must_char and must_char not in "".join(path).translate(VOICE_MAP if ignore_voiced else {}): return
            last_w = path[-1]
            last_c = get_clean_char(last_w.replace("ー", "")[-1], ignore_voiced)
            if not end_char or last_c == end_char:
                results.append(list(path))
            return
        
        step = len(path)
        target = get_target_char(path[-1], shift_count, ignore_voiced, step, is_gyukou)
        
        for next_w in pool:
            if next_w not in path:
                if is_gyukou and step % 2 != 0:
                    next_comp = get_clean_char(next_w.replace("ー", "")[-1], ignore_voiced)
                else:
                    next_comp = get_clean_char(next_w[0], ignore_voiced)
                
                if next_comp == target:
                    solve(path + [next_w])

    start_candidates = [start_word] if start_word else pool
    for w in start_candidates:
        if w in pool:
            if not start_word and start_char and get_clean_char(w[0], ignore_voiced) != start_char: continue
            solve([w])
    
    # ソート処理
    if sort_type == 'length_desc':
        results.sort(key=lambda x: len("".join(x)), reverse=True)
    elif sort_type == 'length_asc':
        results.sort(key=lambda x: len("".join(x)))
    elif sort_type == 'shuffle':
        import random
        random.shuffle(results)

    return jsonify({"routes": results[:3000], "count": len(results)})

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 5000)))
